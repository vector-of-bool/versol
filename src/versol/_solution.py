from __future__ import annotations

from dataclasses import dataclass
from typing import Generic, Iterator

from .incompatibility import Incompatibility
from .interfaces import IKey, RequirementT
from .term import SetRelation, Term
from .util import lazygen

_TermDict = dict[IKey, Term[RequirementT]]


@dataclass(frozen=True)
class BacktrackInfo(Generic[RequirementT]):
    """
    Information requires for backtracking according to a partial solution and a
    conflict. Generated by `PartialSolution.create_backtrack_info` from some
    incompatibility object.
    """

    term: Term[RequirementT]
    satisfier: Assignment[RequirementT]
    """
    The assignment from the partial solution that satisfied the incompatibility
    that generates the conflict.
    """
    prev_sat_level: int
    difference: Term[RequirementT] | None


class PartialSolution(Generic[RequirementT]):
    def __init__(self):
        self.__assignments: list[Assignment[RequirementT]] = []
        """
        A stack of assignments that have been made for the partial solution.
        """
        self.__positives: _TermDict[RequirementT] = {}
        """
        A map from term keys to a a single term that is the intersection of all
        positive assignments.
        """
        self.__negatives: _TermDict[RequirementT] = {}
        """
        A map from term keys to a single term that is the intersection of all
        negative assignments.
        """
        self.__decided_keys: set[IKey] = set()
        """
        The set of keys corresponding to terms that have a decision assignment.
        """

    @lazygen
    def solution(self) -> Iterator[RequirementT]:
        """
        Return the solution that was generated for this partial solution. This
        function should only be called when solving is complete
        """
        for a in self.__assignments:
            if a.is_decision:
                yield a.term.requirement

    def record_derivation(self, term: Term[RequirementT], ic: Incompatibility[RequirementT]) -> None:
        """
        Add a new assignment representing a derived term. This assignment represents
        a fact that was deduced by an incompatibility.
        """
        asn = Assignment(term, len(self.__decided_keys), ic)
        self.__assignments.append(asn)
        self.__learn(asn.term)

    def record_decision(self, term: Term[RequirementT]) -> None:
        """
        Add a new assignment that represents a speculative decision.
        """
        # Record that we have decided for this term's key
        assert term.key not in self.__decided_keys
        self.__decided_keys.add(term.key)
        # Generate the new assignment. It is un-caused, and therefore a decision
        asn = Assignment(term, len(self.__decided_keys), cause=None)
        self.__assignments.append(asn)
        self.__learn(asn.term)

    def relation_to(self, term: Term[RequirementT]) -> SetRelation:
        """
        Get the set relation of the partial solution to the set defined by the
        given term.

        If ``Disjoint``, then the partial solution will never satisfy the given
        term.

        If ``Subset``, then the set defined by the partial solution for the given
        term's key is a subset of the set defined by the term itself. In this
        case, the solution will definitely satisfy the term.

        If ``Overlap``, then the set and the given term have overlap, but are
        not strictly subset/superset of each other.
        """
        pos = self.__positives.get(term.key)
        if pos is not None:
            return pos.relation_to(term)

        neg = self.__negatives.get(term.key)
        if neg is not None:
            return neg.relation_to(term)

        return SetRelation.Overlap

    def satisfies(self, term: Term[RequirementT]) -> bool:
        """
        Return `True` if the partial solution definitely satisfies the given
        term.
        """
        return self.relation_to(term) is SetRelation.Subset

    def next_unsatisfied_requirement(self) -> RequirementT | None:
        """
        Find the next pending requirement in the partial solution that is not fully
        decided. If no undecided assignments remain, then returns `None`.
        """
        undecided = (p.requirement for p in self.__positives.values() if p.key not in self.__decided_keys)
        return next(iter(undecided), None)

    def create_backtrack_info(self, ic: Incompatibility[RequirementT]) -> None | BacktrackInfo[RequirementT]:
        """
        Create backtracking information for an incompatibility. If no backtracking
        is possible, then the solution itself is not possible.
        """
        prev_term: Term[RequirementT] | None = None
        prev_sat: Assignment[RequirementT] | None = None
        diff: None | Term[RequirementT] = None
        prev_sat_level = 0
        for term in ic.terms:
            sat = self.__satisfier_of(term)
            if prev_sat is None:
                prev_sat = sat
                prev_term = term
            elif self.__assignments.index(prev_sat) < self.__assignments.index(sat):
                prev_sat_level = max(prev_sat_level, prev_sat.decision_level)
                prev_term = term
                prev_sat = sat
                diff = None
            else:
                prev_sat_level = max(prev_sat_level, sat.decision_level)
            if prev_term is term:
                assert prev_term is not None
                diff = prev_sat.term.difference(prev_term)
                if not diff.intrinsically_unsatisfiable:
                    prev_sat_level = max(self.__satisfier_of(diff.inverse).decision_level, prev_sat_level)
                else:
                    diff = None

        if prev_sat is not None:
            assert prev_term is not None
            return BacktrackInfo(prev_term, prev_sat, prev_sat_level, diff)
        # Otherwise, we have no backtrack to go to
        return None

    def backtrack_to(self, level: int) -> None:
        """
        Rewind the partial solution to the given decision level. All assignments
        are removed from after the given point
        """
        while self.__assignments[-1].decision_level > level:
            self.__assignments.pop()
        self.__positives.clear()
        self.__negatives.clear()
        self.__decided_keys.clear()
        for a in self.__assignments:
            self.__learn(a.term)
            if a.is_decision:
                self.__decided_keys.add(a.term.key)

    def __satisfier_of(self, term: Term[RequirementT]) -> Assignment[RequirementT]:
        """
        Find the earliest assignment that satisfies the given term.

        Asserts that the given term is satisfied
        """
        isect: Term[RequirementT] | None = None
        tkey = term.key
        # Select all assignments that match the key of the given term. Assignments
        # with differing keys cannot be a satisfier of an unrelated term.
        assignments_for_key = (a for a in self.__assignments if a.term.key == tkey)
        for asmt in assignments_for_key:
            if isect is None:
                isect = asmt.term
            else:
                # Narrow the intersection by the new candidate term
                isect = isect.intersection(asmt.term)
                assert isect
            if isect.implies(term):
                # The new intersection satisfies the term, thus the assignment
                # that resulted in this intersection is the first assignment that
                # caused the partial solution to match the term.
                return asmt
        assert False, (
            "Unreachable: Attempted to look up the satisfier of a term that was expected to "
            "be satisfied by the partial solution, but no partial solution assignment was "
            f"found that satisfied the term [{term=}]"
        )

    def __learn(self, t: Term[RequirementT]) -> None:
        """
        "Learn" the fact of the given term. This updates a dict that records the
        intersection of all known facts about a particular requirement key, leading
        to faster lookup
        """
        pos = self.__positives.get(t.key)
        if pos is not None:
            term = pos.intersection(t)
            assert (
                term is not None
            ), "Intersection resulted in a null term, but we expected to narrow an existing term that has overlap"
            self.__positives[t.key] = term
            return
        term = t
        neg = self.__negatives.pop(t.key, None)
        if neg is not None:
            term = t.intersection(neg)
            assert term is not None, (
                "Intersection resulted in a null term, but we expected to narrow down an "
                "existing term that was overlapping"
            )
        if term.positive:
            self.__positives[term.key] = term
        else:
            self.__negatives[term.key] = term


@dataclass(frozen=True)
class Assignment(Generic[RequirementT]):
    """
    Record of a term in a partial solution that pins a specific requirement.
    """

    term: Term[RequirementT]
    """The term that defines the assignment."""
    decision_level: int
    """The depth of the partial solution at the time this assignment was generated"""
    cause: Incompatibility[RequirementT] | None
    """
    If applicable, the incompatibility that led to this assignment. An assignment
    with a cause is a *derivation*, while an assignment without a cause is a *decision*.
    """

    @property
    def is_decision(self) -> bool:
        """An assignment is a decision if there was no direct incompatibility that generated it"""
        return self.cause is None
